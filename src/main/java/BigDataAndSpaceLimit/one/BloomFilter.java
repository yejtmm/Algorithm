package BigDataAndSpaceLimit.one;

/**
     布隆过滤器
    不安全网页的黑名单包含100亿个黑名单网页，每个网页的URL最多占用64B。
    现在想要实现一个网页过滤系统，利用该系统可以根据网页的URL判断该网页是否在黑名单上，请设计该系统。
    1.该系统允许有万分之一以下的判断失误率。
    2.使用的额外空间不要超过30GB。

 */
public class BloomFilter {

    /**

     如果把黑名单中所有的URL通过数据库或哈希表保存下来，就可以对每条URL进行查询，但是每个URL有64B，数量是100亿个，所以至少需要640GB的空间，不满足要求2。
     如果面试者遇到网页黑名单系统、垃圾邮件过滤系统、爬虫的网址判重系统等题目，又看到系统容忍一定程度的失误率，但是对空间要求比较严格，
     那么很可能是面试官希望面试者具备布隆过滤器的知识。

     一个布隆过滤器精确地代表一个集合，并可以精确判断一个元素是否在集合中。注意，只是精确代表和精确判断，到底有多精确呢？
     这完全在于你具体的设计，但想做到完全正确是不可能的。
     布隆过滤器的优势在于使用很少的空间就可以将准确率做到很高的程度，该结构由BurtonHoward Bloom于1970年提出。

     首先介绍哈希函数（散列函数）的概念。
     哈希函数的输入域可以是非常大的范围，比如，任意一个字符串，但是输出域是固定的范围，假设为S，并具有如下性质：
     1.典型的哈希函数都有无限的输入值域。
     2.当给哈希函数传入相同的输入值时，返回值一样。
     3.当给哈希函数传入不同的输入值时，返回值可能一样，也可能不一样，这是当然的。因为输出域统一是S，所以会有不同的输入值对应在S中的一个元素上。
     4.最重要的性质是很多不同的输入值所得到的返回值会均匀地分布在S上。

     第1～3点性质是哈希函数的基础，
     第4点性质是评价一个哈希函数优劣的关键，不同的输入值所得到的返回值越均匀地分布在S上，哈希函数就越优秀，并且这种均匀分布与输入值出现的规律无关。
     比如，＂aaa1＂、＂aaa2＂、＂aaa3＂三个输入值比较类似，但经过优秀的哈希函数计算后的结果应该相差非常大。
     一些哈希函数经典的实现，比如MD5和SHA1算法，但了解这些算法的细节并不在准备代码面试的范围中。
     如果一个优秀的哈希函数能够做到很多不同的输入值所得到的返回值非常均匀地分布在S上，那么将所有的返回值对m取余（%m），
     可以认为所有的返回值也会均匀地分布在0～m-1的空间上。

     接下来介绍一下什么是布隆过滤器。
     假设有一个长度为m的bit类型的数组，即数组中的每一个位置只占一个bit，如我们所知，每一个bit只有0和1两种状态，

           —— —— —— —— ..... —— —— —— ..... —— —— ——
            0  1  2          i  i+1         m-3 m-2 m-1

     再假设一共有k个哈希函数，这些函数的输出域S都大于或等于m，并且这些哈希函数都足够优秀，彼此之间也完全独立。
     那么对同一个输入对象（假设是一个字符串，记为URL），经过 k个哈希函数算出来的结果也是独立的，可能相同，也可能不同，但彼此独立。
     对算出来的每一个结果都对m取余（%m），然后在bit array上把相应的位置设置为1（涂黑）。

     我们把bit类型的数组记为bitMap。
     至此，一个输入对象对bitMap的影响过程就结束了，也就是bitMap中的一些位置会被涂黑。
     接下来按照该方法处理所有的输入对象，每个对象都可能把bitMap中的一些白位置涂黑，也可能遇到已经涂黑的位置，
     遇到已经涂黑的位置让其继续为黑即可。处理完所有的输入对象后，可能bitMap中已经有相当多的位置被涂黑。
     至此，一个布隆过滤器生成完毕，这个布隆过滤器代表之前所有输入对象组成的集合。

     那么在检查阶段如何检查某一个对象是否是之前的某一个输入对象呢？假设一个对象为a，想检查它是否是之前的输入对象，就把a通过k个哈希函数算出k个值，
     然后把k个值取余（%m），就得到在[0，m-1]范围上的k个值。接下来在bitMap上看这些位置是不是都为黑。如果有一个不为黑，说明a一定不在这个集合里。
     如果都为黑，说明a在这个集合里，但可能有误判。
     再解释具体一点，如果a的确是输入对象，那么在生成布隆过滤器时，bitMap中相应的k个位置一定已经涂黑了，所以在检查阶段，a一定不会被漏过，这个不会产生误判。
     会产生误判的是，a明明不是输入对象，但如果在生成布隆过滤器的阶段因为输入对象过多，而bitMap过小，则会导致bitMap绝大多数的位置都已经变黑。
     那么在检查a时，可能a对应的k个位置都是黑的，从而错误地认为a是输入对象。通俗地说，布隆过滤器的失误类型是“宁可错杀三千，绝不放过一个”。


     布隆过滤器到底该怎么实现？如果 bitMap的大小 m相比输入对象的个数n过小，失误率会变大。
     接下来先介绍根据n的大小和我们想达到的失误率p，如何确定布隆过滤器的大小m和哈希函数的个数k，最后是布隆过滤器的失误率分析。下面以本题为例来说明。

     黑名单中样本的个数为100亿个，记为n；失误率不能超过0.01%，记为p；
     每个样本的大小为 64B，这个信息不会影响布隆过滤器的大小，只和选择哈希函数有关，一般的哈希函数都可以接收64B的输入对象，
     所以使用布隆过滤器还有一个好处是不用顾忌单个样本的大小，它丝毫不能影响布隆过滤器的大小。

     所以n=100亿，p=0.01%，布隆过滤器的大小m由以下公式确定：
                    n × ln(p)
            m = - ————————————
                           2
                     (ln2)

     根据公式计算出m=19.19n，向上取整为20n，即需要2000亿个bit，也就是25GB。
     哈希函数的个数由以下公式决定：
                       m           m
            K = ln2 × ——— = 0.7 × ———
                       n           n

     计算出哈希函数的个数为k=14个。
     然后用25GB的bitMap再单独实现14个哈希函数，根据如上描述生成布隆过滤器即可。

     因为我们在确定布隆过滤器大小的过程中选择了向上取整，所以还要用如下公式确定布隆过滤器真实的失误率为：
                      nk
                   - ————   k
           ( 1 - e     m   )

     根据这个公式算出真实的失误率为0.006%，这是比0.01%更低的失误率，哈希函数本身不占用什么空间，所以使用的空间就是bitMap的大小（即25GB），
     服务器的内存都可以达到这个级别，所有要求达标。之后的判断阶段与上文的描述一样。


     布隆过滤器失误率分析。假设布隆过滤器中的k个哈希函数足够优秀且各自独立，每个输入对象都等概率地散列到bitMap中m个bit中的任意k个位置，
     且与其他元素被散列到哪儿无关。那么对某一个bit位来说，一个输入对象在被k个哈希函数散列后，这个位置依然没有被涂黑的概率为
                   1   k
            ( 1 - ————)
                    m

     经过n个输入对象后，这个位置依然没有被涂黑的概率为：
                    1   kn
            ( 1 - ————)
                    m

     那么被涂黑的概率就为:

                    1   kn
        1 - ( 1 - ————)
                    m

     在检查阶段，检查k个位置都为黑的概率为：                   -kn
                      1  kn   k                  1   -m×—————     K
         ( 1 - ( 1 - ———)   )    =  ( 1 - ( 1 - ——— )     m     )
                      m                          m

     在x-＞0时，（1+x）^（1/x）-＞e。上面等式的右边可以认为m为很大的数，所以-1/m-＞0，则化简为：






     */


}
