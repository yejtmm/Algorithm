package OtherIssues.two;

/**
 给定两个不等于0的整数M和N，求M和N的最大公约数。

 */
public class CommonDivisor {

    /**
     一个很简单的求两个数最大公约数的算法是欧几里得在其《几何原本》中提出的欧几里得算法，又称为辗转相除法。

     具体做法为：如果q和r分别是m除以n的商及余数，即m=nq+r，那么m和n的最大公约数等于n和r的最大公约数。

     */
    public int gcd(int m, int n){
        return n == 0 ? m : gcd(n, m % n);
    }

    /**
     关于阶乘

     给定一个非负整数N，返回N！结果的末尾为0的数量。例如：3！=6，结果的末尾没有0，则返回0。5！=120，结果的末尾有1个0，返回1。
     1000000000！，结果的末尾有249999998个0，返回249999998。

     进阶问题：给定一个非负整数N，如果用二进制数表达N！的结果，返回最低位的1在哪个位置上，认为最右的位置为位置0。
     例如：1！=1，最低位的1在0位置上。2！=2，最低位的1在1位置上。1000000000！，最低位的1在999999987位置上。


     无论是原问题还是进阶问题，通过算出真实的阶乘结果后再处理的方法无疑是不合适的，因为阶乘的结果通常很大，非常容易溢出，
     而且会增加计算的复杂性。

     原问题的一个普通解法。对原问题来说，N！结果的末尾有多少个0的问题可以转换为1，2，3，…，N-1，N的序列中一共有多少个因子5。
     这是因为进行1×2×3×…×N操作的过程中，因子2的数目比因子5的数目多，所以不管有多少个因子5，都有足够的因子2与其相乘得到 10。
     所以只要找出 1～N所有的数中一共含有多少个因子 5就可以。
     */

    public int zeroNum1(int num){
        if(num < 0){
            return 0;
        }
        int res = 0;
        int cur = 0;
        for (int i = 5; i < num + 1; i = i + 5){
            cur = i;
            while (cur % 5 == 0){
                res++;
                cur /= 5;
            }
        }
        return res;
    }

    /**
     以上方法的效率并不高，对每一个数i来说，处理的代价是logi（以5为底），一共有O（N）个数。所以时间复杂度为O（NlogN）。
     现在介绍原问题的最优解。我们把1～N的数列出来，1，2，3，4，5，6，7，8，9，10…，15…，20…，25…，30…，35…，40…，45…，50…，75…，100…，125…
     发现：若每5个含有0个因子5的数（1，2，3，4，5）组成一组，这一组中的第5个数就含有51的因子（5）。若每5个含有1个因子5的数（5，10，15，20，25）组成一组，
     这一组中的第5个数就含有52的因子（25）。若每5个含有2个因子5的数（25，50，75，100，125）组成一组，这一组中的第5个数就含有53的因子（125）。
     若每5个含有i个因子5的数组成一组，这一组中的第5个数就含有5i+1的因子……

     所以，如果把N！的结果中因子5的总个数记为Z，就可以得到如下关系：Z=N/5+N/（52）+N/（53）+...+N/（5i） （i一直增长，直到5i＞N）
     用上文的例子来理解就是，1～N中有N/5个数，这每个数都能贡献一个5；然后1～N中有N/（52）个数，这每个数又都能贡献一个5……。

     */

    public int zeroNum2(int num){
        if (num < 0){
            return 0;
        }
        int res = 0;
        while (num != 0){
            res += num / 5;
            num /= 5;
        }
        return res;
    }

    /**
     可以看到，如果一共有N个数，最优解的时间复杂度为O（logN），以5为底。
     进阶问题。
     解法一:
        与原问题的解法类似，最低位的1在哪个位置上，完全取决于1～N的数中因子2有多少个，因为只要出现一个因子2，最低位的1就会向左位移一位。
        所以，如果把N！的结果中因子2的总个数记为Z，我们就可以得到如下关系Z=N/2+N/4+N/8+…+N/（2i）（i一直增长，直到2i＞N）。
     */

    public int rightOne1(int num){
        if (num < 1){
            return -1;
        }
        int res = 0;
        while (num != 0){
            num >>>= 1;
            res += num;
        }
        return res;
    }

    /**
     解法二：
     如果把N！的结果中因子2的总个数记为Z，把N的二进制数表达式中1的个数记为m，还存在如下一个关系Z=N-m，也就是可以证明N/2+N/4+N/8+…=N-m。
     注意，这里的/不是数学上的除法，而是计算科学中的除法，即结果要向下取整。
     首先，如果一个整数 K正好为 2的某次方（K=2i），那么求和公式 K/2+K/4+K/8+…=K/2+K/4+K/8+…+1，也就是在K=2i时，计算科学中的除法和数学上的除法等效。
     所以根据等比数列求和公式 S=（末项×公比-首项）/（公比-1），可以得到K/2+K/4+K/8+…=K-1。

     如果在N的二进制表达中有m个1，那么N可以表达为：N=K1+K2+K3+…+Km，其中所有的K都等于2的某次方。
     例如，N=10110时，N=10000+100+10。
     于是有N/2+N/4+…=（K1+K2+K3+…+Km）/2+（K1+K2+K3+…+Km）/4+…=K1/2+K1/4+K1/8+…+1+K2/2+K2/4+…+1+…+Km/2+Km/4+…+1。

     K1，K2，…，Km 都等于 2 的某次方。所以等式右边=K1-1+K2-1+K3-1+…+Km-1=（K1+…+Km）-m=N-m。至此，Z=N-m证明完毕。
     */

    public int rightOne2(int num){
        if (num < 1){
            return -1;
        }
        int ones = 0;
        int tmp = num;
        while (tmp != 0){
            ones += (tmp & 1) != 0 ? 1 : 0;
            tmp >>>= 1;
        }
        return num - ones;
    }

}
