package RecursionAndDynamicProgramming.one;

/**

    给定整数N，返回斐波那契数列的第N项。
    补充问题 1：给定整数 N，代表台阶数，一次可以跨 2个或者 1个台阶，返回有多少种走法。
   【举例】
    N=3，可以三次都跨1个台阶；
        也可以先跨2个台阶，再跨1个台阶；
        还可以先跨1个台阶，再跨2个台阶。
    所以有三种走法，返回3。

  补充问题 2：假设农场中成熟的母牛每年只会生 1 头小母牛，并且永远不会死。
           第一年农场有1只成熟的母牛，从第二年开始，母牛开始生小母牛。每只小母牛3年之后成熟又可以生小母牛。
           给定整数N，求出N年后牛的数量。
  【举例】
   N=6，第1年1头成熟母牛记为a；第2年a生了新的小母牛，记为b，总牛数为2；第3年a生了新的小母牛，记为c，总牛数为3；
   第4年a生了新的小母牛，记为d，总牛数为4。第5年b成熟了，a和b分别生了新的小母牛，总牛数为6；
   第6年c也成熟了，a、b和c分别生了新的小母牛，总牛数为9，返回9。

   对以上所有的问题，请实现时间复杂度为O（logN）的解法。
 */

public class Fibonacci {

    /**
     原问题。O（2N）的方法。
     斐波那契数列为1，1，2，3，5，8，…，也就是除第1项和第2项为1以外，对于第N项，有F（N）=F（N-1）+F（N-2），
     于是很轻松地写出暴力递归的代码。
     */

    public int f1(int n){
        int m = 0;
//        if(n < 1){
//            return 0;
//        }
//        if(n == 1 || n == 2){
//            return 1;
//        }
//        return f1(n - 1) + f1(n - 2);
        if(n == 1 || n == 2){
            m = 1;
        }else if (m > 2){
            m = f1(n - 1) + f1(n - 2);
        }
        return m;
    }
    /**
     O（N）的方法。
     斐波那契数列可以从左到右依次求出每一项的值，那么通过顺序计算求到第N项即可。
     */

    public int f2(int n){
        if(n < 1){
            return 0;
        }
        if(n == 1 || n == 2){
            return 1;
        }
        int res = 1;
        int pre = 1;
        int tmp = 0;
        for (int i = 2; i < n; i++){
            tmp = res;
            res += pre;
            pre = tmp;
        }
        return res;
    }

    /**
     O（logN）的方法。
     如果递归式严格遵循F（N）=F（N-1）+F（N-2），对于求第N项的值，有矩阵乘法的方式可以将时间复杂度降至 O（logN）。
     F（n）= F（n-1）+ F（n-2），是一个二阶递推数列，一定可以用矩阵乘法的形式表示，且状态矩阵为2×2的矩阵：
                                        | a  b|
     ( F(n),F(n-1)) = ( F(n-1),F(n-2))× |     |
                                        | c  d|

     把斐波那契数列的前 4 项 F(1) == 1, F(2) == 1, F(3) == 2, F(4) == 3代入
     可以求出状态矩阵：

                | a   c |     | 1  1 |
                |       |  =  |      |
                | b   d |     | 1  0 |

     求矩阵之后，当 n > 2时， 原来的公式可以简化为：
                                               | 1  1 |          | 1  1 |
                 （F(3),F(2)） = (F(2),F(1)) × |      | = (1,1)× |      |
                                              | 1  0 |          | 1  0 |

                                             | 1  1 |          | 1  1 |
               （F(4),F(3)） = (F(3),F(3)) × |      | = (1,1)× |      |
                                            | 1  0 |          | 1  0 |
                                          :
                                         :
                                           | 1  1 |          | 1  1 | n-2
   F(n),F(n - 1)）= (F(n - 1),F(n - 2)) ×  |      | = (1,1)× |      |
                                          | 1  0 |          | 1  0 |


     所以，求斐波那契数列第N项的问题就变成了如何用最快的方法求一个矩阵N次方的问题，
     而求矩阵N次方的问题明显是一个能够在O（logN）时间内解决的问题。
     为了表述方便，我们现在用求一个整数 N 次方的例子来说明，
     因为只要理解了如何在 O（logN）的时间复杂度内求整数 N次方的问题，对于求矩阵N次方的问题是同理的，
     区别是矩阵乘法和整数乘法在细节上有些不一样，但对于怎么乘更快，两者的道理相同。


     假设一个整数是10，如何最快地求解10的75次方。
     1. 75的二进制数形式为1001011。
     2. 10的75次方=1064×108×102×101。
     在这个过程中，我们先求出101，然后根据101求出102，再根据102求出104，……，最后根据1032求出1064，
     即75的二进制数形式总共有多少位，我们就使用了几次乘法。
     3.在步骤 2 进行的过程中，把应该累乘的值相乘即可，比如 1064、108、102、101应该累乘，
     因为64、8、2、1对应到75的二进制数中，相应的位上是1；而1032、1016、104不应该累乘，
     因为32、16、4对应到75的二进制数中，相应的位上是0。

     对矩阵来说同理，求矩阵m的p次方

     */

    public int[] [] matrixPower(int [] [] m, int p){
        int [] [] res = new int[m.length][m[0].length];
        //先把 res设为单位矩阵，相当与整数中的 1
        for(int i = 0; i < res.length; ++i){
            res[i][i] = 1;
        }
        int [] [] tmp = m;
        for(; p != 0; p >>= 1){
            if((p & 1) != 0){
                res = multiMatrix(res, tmp);
            }
        }
        return res;
    }

    public int [] [] multiMatrix(int[] [] m1, int[] [] m2){
        int[][] res = new int[m1.length][m2[0].length];
        for (int i = 0; i < m1.length; ++i){
            for (int j = 0; j < m2[0].length; ++j){
                for (int k = 0; k < m2.length; ++k){
                    res[i][j] += m1[i][k] * m2[k][j];
                }
            }
        }
        return res;
    }

    /**
     用矩阵乘法求解斐波那契数列第N项的全部过程
     */

    public int f3(int n){
        if (n < 1){
            return 0;
        }
        if(n == 1 || n == 2){
            return 1;
        }

        int [] [] base = {{1, 1}, {1, 0}};
        int [] [] res = matrixPower(base, n - 2);
        return res[0][0] + res[1][0];
    }

    /**
     补充问题1。如果台阶只有1级，方法只有1种。如果台阶有2级，方法有2种。
     如果台阶有N级，最后跳上第N级的情况，要么是从N-2级台阶直接跨2级台阶，
     要么是从N-1级台阶跨1级台阶，所以台阶有N级的方法数为跨到N-2级台阶的方法数加上跨到N-1级台阶的方法数，
     即S（N）=S（N-1）+S（N-2），初始项S（1）==1，S（2）==2。
     所以，类似斐波那契数列，唯一的不同就是初始项不同。可以很轻易地写出O（2N）与O（N）的方法，
     */

    public int s1(int n){
        if(n < 1){
            return 0;
        }
        if (n == 1 || n == 2){
            return n;
        }
        return s1(n - 1) + s1(n - 2);
    }

    public int s2(int n){
        if (n < 1){
            return 0;
        }
        if (n == 1 || n == 2){
            return n;
        }
        int res = 2;
        int pre = 1;
        int tmp = 0;
        for (int i = 3; i <= n; i++){
            tmp = res;
            res = res + pre;
            pre = tmp;
        }
        return res;
    }

    /**
     O（logN）的方法。表达式 S（n）=S（n-1）+S（n-2）是一个二阶递推数列，同样，用上文矩阵乘法的方法，
     根据前4项S（1）==1，S（2）==2，S（3）==3，S（4）==5，求出状态矩阵：
                |        |       |      |
                | a    b |       | 1  1 |
                |        |    =  |      |
                | c    d |       | 1  0 |
                |        |       |      |

     根据上文过程得到：
                                                 | 1  1 |n-2             | 1  1 |n-2
                (S(n),S(n - 1)) = (S(2),S(1)) *  |      |     = (2, 1) * |      |
                                                 | 1  0 |                | 1  0 |

     全部实现见 S3
     */
    public int s3(int n){
        if (n < 1){
            return 0;
        }
        if(n == 1 || n == 2){
            return n;
        }
        int [] [] base = { {1, 1}, {1, 0}};
        int [] [] res = matrixPower(base, n - 2);
        return 2 * res[0][0] + res[1][0];
    }

    /**
     补充问题2。所有的牛都不会死，所以第N-1年的牛会毫无损失地活到第N年。
     同时所有成熟的牛都会生1头新的牛，那么成熟牛的数量如何估计？
     就是第N-3年的所有牛，到第N年肯定都是成熟的牛，其间出生的牛肯定都没有成熟。
     所以C（n）=C（n-1）+C（n-3），初始项为C（1）==1，C（2）==2，C（3）==3。
     这个和斐波那契数列又十分类似，只不过C（n）依赖C（n-1）和C（n-3）的值，
     而斐波那契数列 F（n）依赖 F（n-1）和 F（n-2）的值。
     同样可以轻易地写出 O（2N）与 O（N）的方法，请参看如下代码中的c1和c2方法。
     */

    public int c1(int n){
        if(n < 1){
            return 0;
        }
        if(n == 1 || n == 2 || n == 3){
            return n;
        }
        return c1(n - 1) + c1(n - 3);
    }

    public int c2(int n){
        if(n < 1){
            return 0;
        }
        if(n == 1 || n == 2 || n == 3){
            return n;
        }
        int res = 3;
        int pre = 2;
        int prepre = 1;
        int tmp1 = 0;
        int tmp2 = 0;
        for (int i = 4; i <= n; i++){
            tmp1 = res;
            tmp2 = pre;
            res = res + prepre;
            pre = tmp1;
            prepre = tmp2;
        }
        return res;
    }

    /**

     O（logN）的方法。C（n）=C（n-1）+C（n-3）是一个三阶递推数列，一定可以用矩阵乘法的形式表示，
     且状态矩阵为3×3的矩阵。
                                           | 1 1 0 |n-3    | 1 1 0 |n-3
        ( Cn, Cn-1,Cn-2) = ( C3, C2, C1) × | 0 0 1 |    =  | 0 0 1 |
                                           | 1 0 0 |       | 1 0 0 |

     把前5项C（1）==1，C（2）==2，C（3）==3，C（4）==4，C（5）==6代入，求出状态矩阵

                   | a b c |    | 1 1 0 |
                   | d e f | =  | 0 0 1 |
                   | g h i |    | 1 0 0 |

     求矩阵之后，当n>3时，原来的公式可化简为：
                                         | 1 1 0 |n-3                | 1 1 0 |n-3
     ( Cn, Cn-1,Cn-2) = ( C3, C2, C1) ×  | 0 0 1 |    =  (3, 2, 1) * | 0 0 1 |
                                         | 1 0 0 |                   | 1 0 0 |

     接下来的过程又是利用加速矩阵乘法的方式进行实现。
     */

    public int C3(int n){

        if(n < 1){
            return 0;
        }
        if(n == 1 || n == 2 || n == 3){
            return n;
        }
        int [] [] base = {{1,1,0},{0,0,1},{1,0,0}};
        int [] [] res = matrixPower(base, n - 3);
        return 3 * res[0][0] + 2 * res[1][0] + res[2][0];
    }


    /**

     如果递归式严格符合F（n）=a×F（n-1）+b×F（n-2）+...+k×F（n-i），那么它就是一个i阶的递推式，
     必然有与i×i的状态矩阵有关的矩阵乘法的表达。一律可以用加速矩阵乘法的动态规划将时间复杂度降为O（logN）。

     */

}
