package RecursionAndDynamicProgramming;

/**

    给定整数N，返回斐波那契数列的第N项。
    补充问题 1：给定整数 N，代表台阶数，一次可以跨 2个或者 1个台阶，返回有多少种走法。
   【举例】
    N=3，可以三次都跨1个台阶；
        也可以先跨2个台阶，再跨1个台阶；
        还可以先跨1个台阶，再跨2个台阶。
    所以有三种走法，返回3。

  补充问题 2：假设农场中成熟的母牛每年只会生 1 头小母牛，并且永远不会死。
           第一年农场有1只成熟的母牛，从第二年开始，母牛开始生小母牛。每只小母牛3年之后成熟又可以生小母牛。
           给定整数N，求出N年后牛的数量。
  【举例】
   N=6，第1年1头成熟母牛记为a；第2年a生了新的小母牛，记为b，总牛数为2；第3年a生了新的小母牛，记为c，总牛数为3；
   第4年a生了新的小母牛，记为d，总牛数为4。第5年b成熟了，a和b分别生了新的小母牛，总牛数为6；
   第6年c也成熟了，a、b和c分别生了新的小母牛，总牛数为9，返回9。

   对以上所有的问题，请实现时间复杂度为O（logN）的解法。
 */

public class Fibonacci {

    /**
     原问题。O（2N）的方法。
     斐波那契数列为1，1，2，3，5，8，…，也就是除第1项和第2项为1以外，对于第N项，有F（N）=F（N-1）+F（N-2），
     于是很轻松地写出暴力递归的代码。
     */

    public int f1(int n){
        int m = 0;
//        if(n < 1){
//            return 0;
//        }
//        if(n == 1 || n == 2){
//            return 1;
//        }
//        return f1(n - 1) + f1(n - 2);
        if(n == 1 || n == 2){
            m = 1;
        }else if (m > 2){
            m = f1(n - 1) + f1(n - 2);
        }
        return m;
    }
    /**
     O（N）的方法。
     斐波那契数列可以从左到右依次求出每一项的值，那么通过顺序计算求到第N项即可。
     */

    public int f2(int n){
        if(n < 1){
            return 0;
        }
        if(n == 1 || n == 2){
            return 1;
        }
        int res = 1;
        int pre = 1;
        int tmp = 0;
        for (int i = 2; i < n; i++){
            tmp = res;
            res += pre;
            pre = tmp;
        }
        return res;
    }

    /**
     O（logN）的方法。
     如果递归式严格遵循F（N）=F（N-1）+F（N-2），对于求第N项的值，有矩阵乘法的方式可以将时间复杂度降至 O（logN）。
     F（n）= F（n-1）+ F（n-2），是一个二阶递推数列，一定可以用矩阵乘法的形式表示，且状态矩阵为2×2的矩阵：
                                        | a  b|
     ( F(n),F(n-1)) = ( F(n-1),F(n-2))× |     |
                                        | c  d|

     把斐波那契数列的前 4 项 F(1) == 1, F(2) == 1, F(3) == 2, F(4) == 3代入
     可以求出状态矩阵：

                | a   c |     | 1  1 |
                |       |  =  |      |
                | b   d |     | 1  0 |

     求矩阵之后，当 n > 2时， 原来的公式可以简化为：
                                               | 1  1 |          | 1  1 |
                 （F(3),F(2)） = (F(2),F(1)) × |      | = (1,1)× |      |
                                              | 1  0 |          | 1  0 |

                                             | 1  1 |          | 1  1 |
               （F(4),F(3)） = (F(3),F(3)) × |      | = (1,1)× |      |
                                            | 1  0 |          | 1  0 |
                                          :
                                         :
                                           | 1  1 |          | 1  1 | n-2
   F(n),F(n - 1)）= (F(n - 1),F(n - 2)) ×  |      | = (1,1)× |      |
                                          | 1  0 |          | 1  0 |


     所以，求斐波那契数列第N项的问题就变成了如何用最快的方法求一个矩阵N次方的问题，
     而求矩阵N次方的问题明显是一个能够在O（logN）时间内解决的问题。
     为了表述方便，我们现在用求一个整数 N 次方的例子来说明，
     因为只要理解了如何在 O（logN）的时间复杂度内求整数 N次方的问题，对于求矩阵N次方的问题是同理的，
     区别是矩阵乘法和整数乘法在细节上有些不一样，但对于怎么乘更快，两者的道理相同。


     假设一个整数是10，如何最快地求解10的75次方。
     1. 75的二进制数形式为1001011。
     2. 10的75次方=1064×108×102×101。
     在这个过程中，我们先求出101，然后根据101求出102，再根据102求出104，……，最后根据1032求出1064，
     即75的二进制数形式总共有多少位，我们就使用了几次乘法。
     3.在步骤 2 进行的过程中，把应该累乘的值相乘即可，比如 1064、108、102、101应该累乘，
     因为64、8、2、1对应到75的二进制数中，相应的位上是1；而1032、1016、104不应该累乘，
     因为32、16、4对应到75的二进制数中，相应的位上是0。

     对矩阵来说同理，求矩阵m的p次方

     */

    public int[] [] matrixPower(int [] [] m, int p){
        int [] [] res = new int[m.length][m[0].length];
        //先把 res设为单位矩阵，相当与整数中的 1
        for(int i = 0; i < res.length; ++i){
            res[i][i] = 1;
        }
        int [] [] tmp = m;
        for(; p != 0; p >>= 1){
            if((p & 1) != 0){
                res = multiMatrix(res, tmp);
            }
        }
        return res;
    }

    public int [] [] multiMatrix(int[] [] m1, int[] [] m2){
        int[][] res = new int[m1.length][m2[0].length];
        for (int i = 0; i < m1.length; ++i){
            for (int j = 0; j < m2[0].length; ++j){
                for (int k = 0; k < m2.length; ++k){
                    res[i][j] += m1[i][k] * m2[k][j];
                }
            }
        }
        return res;
    }

    /**
     用矩阵乘法求解斐波那契数列第N项的全部过程
     */

    public int f3(int n){
        if (n < 1){
            return 0;
        }
        if(n == 1 || n == 2){
            return 1;
        }

        int [] [] base = {{1, 1}, {1, 0}};
        int [] [] res = matrixPower(base, n - 2);
        return res[0][0] + res[1][0];
    }

    /**
     补充问题1。如果台阶只有1级，方法只有1种。如果台阶有2级，方法有2种。
     如果台阶有N级，最后跳上第N级的情况，要么是从N-2级台阶直接跨2级台阶，
     要么是从N-1级台阶跨1级台阶，所以台阶有N级的方法数为跨到N-2级台阶的方法数加上跨到N-1级台阶的方法数，
     即S（N）=S（N-1）+S（N-2），初始项S（1）==1，S（2）==2。
     所以，类似斐波那契数列，唯一的不同就是初始项不同。可以很轻易地写出O（2N）与O（N）的方法，
     */



}
